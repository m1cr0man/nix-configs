{ pkgs, lib, config, ... }:
let
  cfg = config.m1cr0man.zfs;

  # Like lib.mkEnableOption but defaults to true
  mkEnableOption = name: lib.mkOption {
    default = true;
    example = true;
    description = "Whether to enable ${name}.";
    type = lib.types.bool;
  };

  serviceConfig = {
    after = [ "zfs.target" ];
    restartIfChanged = false;
    path = [ pkgs.zfsUnstable ];
    serviceConfig.Type = "oneshot";
  };

  # Although this script is technically impure, we use
  # runCommandLocal to help guarantee a unique entry per host.
  # Technically if you build a closure and then copy to a remote
  # host it wouldn't be unique, but that's something I'm unlikely
  # to do right now.
  defaultHostKey = pkgs.runCommandLocal "initrd-host-keys"
    {
      buildInputs = [ pkgs.openssh ];
    } ''
    ssh-keygen \
      -t ed25519 \
      -f initrd_key \
      -C "Initrd host key generated by NixOS" \
      -N ""
    mv initrd_key $out
  '';

  unlockerScript = pkgs.writeShellScript "unlock-zfs.sh" (
    builtins.concatStringsSep "\n" (map
      (ds: ''
        if ! zfs list -Ho name '${ds}' > /dev/null 2>&1; then
          zpool import '${ds}'
        fi
        echo Unlocking '${ds}'
        zfs load-key '${ds}'
      '')
      cfg.encryptedDatasets)
  );
in
{
  options.m1cr0man.zfs = {
    enable = mkEnableOption "my ZFS customisations";

    enableScrubbing = mkEnableOption "incremental ZFS scrubbing";

    encryptedDatasets = with lib; mkOption {
      type = types.listOf types.str;
      default = [ ];
      description = ''
        ZFS datasets that need decrypting on boot.
        If set, initrd networking + SSH will be enabled
        to allow for decrypting of encrypted datasets
      '';
    };

    initrdHostKey = with lib; mkOption {
      type = types.path;
      default = defaultHostKey;
      # Set defaultText so we don't inadvertently load the file into the store when reading docs.
      defaultText = "Generated at build time";
      description = "Private key to use for the initrd SSH server";
    };

    scrubStartTime = with lib; mkOption {
      default = "daily";
      type = types.str;
      description = ''
        When to start ZFS scrub. Any systemd-time format.
        See https://www.freedesktop.org/software/systemd/man/systemd.time.html#Calendar%20Events
      '';
    };

    scrubStopTime = with lib; mkOption {
      default = "*-*-* 00:30:00";
      type = types.str;
      description = ''
        When to stop ZFS scrub. Any systemd-time format.
        See https://www.freedesktop.org/software/systemd/man/systemd.time.html#Calendar%20Events
      '';
    };

    arcMaxGb = with lib; mkOption {
      default = 4;
      type = types.int;
      description = ''
        Maximum size of the in memory ARC cache in gigabytes.
      '';
    };
  };

  config = lib.mkIf (cfg.enable) {
    boot.supportedFilesystems = [ "zfs" ];
    boot.zfs = {
      forceImportRoot = true;
      forceImportAll = lib.mkDefault false;
    };

    # Set some sane values for the kmod
    boot.extraModprobeConfig = ''
      options zfs zfs_scrub_min_time_ms=50
      options zfs zfs_arc_max=${builtins.toString (cfg.arcMaxGb * 1000 * 1000 * 1000)}
    '';

    # Set up initrd unlocker system
    boot.initrd = lib.mkIf (cfg.encryptedDatasets != [ ]) {
      extraFiles."unlock-zfs.sh".source = unlockerScript;

      # Use DHCP during the initrd, then undo the config before stage 2 boot
      # TODO compare to flushBeforeStage2
      postMountCommands = ''
        ip a flush eth0
        ip l set eth0 down
      '';
      network = {
        enable = true;
        ssh = {
          enable = true;
          port = 6416;
          authorizedKeys = config.users.users.root.openssh.authorizedKeys.keys;
          hostKeys = [ cfg.initrdHostKey ];
        };
      };
    };

    # Set auto snapshot settings. Will still need to be toggled on a per-dataset basis
    services.zfs.autoSnapshot = {
      enable = true;
      flags = "-k -p --utc";
      frequent = 4;
      hourly = 6;
      daily = 7;
      weekly = 0;
      monthly = 1;
    };

    # Automatically scrub the disk for 30 minutes every day
    # Avoids drive murder
    systemd.services.zfs-scrub = serviceConfig // {
      description = "Start ZFS incremental scrub";
      script = "zpool scrub $(zpool list -Ho name)";
    };

    systemd.services.zfs-scrub-stop = serviceConfig // {
      description = "Stop ZFS incremental scrub";
      script = "zpool scrub -p $(zpool list -Ho name) || true";
    };

    systemd.timers.zfs-scrub = {
      description = "Start ZFS incremental scrub";
      wantedBy = [ "timers.target" ];
      after = [ "zfs.target" ];
      timerConfig = {
        OnCalendar = config.m1cr0man.zfs.scrubStartTime;
        RandomizedDelaySec = 60;
        Persistent = false;
      };
    };

    # Runs 30 minutes after the above, or on next boot
    systemd.timers.zfs-scrub-stop = {
      description = "Stop ZFS incremental scrub";
      wantedBy = [ "timers.target" ];
      after = [ "zfs.target" ];
      timerConfig = {
        OnCalendar = config.m1cr0man.zfs.scrubStopTime;
        RandomizedDelaySec = 60;
        Persistent = true;
      };
    };
  };
}
